{"version":3,"file":"TaskOption-e7d917a4.js","sources":["../../../../node_modules/.pnpm/fp-ts@2.16.1/node_modules/fp-ts/es6/OptionT.js","../../../../node_modules/.pnpm/fp-ts@2.16.1/node_modules/fp-ts/es6/TaskOption.js"],"sourcesContent":["import { ap as ap_ } from './Apply';\nimport { constant, flow, pipe } from './function';\nimport { map as map_ } from './Functor';\nimport * as O from './Option';\nexport function some(F) {\n    return flow(O.some, F.of);\n}\nexport function zero(F) {\n    return constant(F.of(O.none));\n}\nexport function fromF(F) {\n    return function (ma) { return F.map(ma, O.some); };\n}\nexport function fromNullable(F) {\n    return flow(O.fromNullable, F.of);\n}\nexport function fromNullableK(F) {\n    var fromNullableF = fromNullable(F);\n    return function (f) { return flow(f, fromNullableF); };\n}\nexport function chainNullableK(M) {\n    var chainM = chain(M);\n    var fromNullableKM = fromNullableK(M);\n    return function (f) { return chainM(fromNullableKM(f)); };\n}\nexport function fromOptionK(F) {\n    return function (f) { return flow(f, F.of); };\n}\nexport function chainOptionK(M) {\n    var chainM = chain(M);\n    var fromOptionKM = fromOptionK(M);\n    return function (f) { return chainM(fromOptionKM(f)); };\n}\nexport function fromPredicate(F) {\n    return function (predicate) {\n        return function (a) {\n            return F.of(O.fromPredicate(predicate)(a));\n        };\n    };\n}\nexport function fromEither(F) {\n    return flow(O.fromEither, F.of);\n}\nexport function match(F) {\n    return function (onNone, onSome) { return function (ma) { return F.map(ma, O.match(onNone, onSome)); }; };\n}\nexport function matchE(M) {\n    return function (onNone, onSome) { return function (ma) { return M.chain(ma, O.match(onNone, onSome)); }; };\n}\nexport function getOrElse(M) {\n    return function (onNone) { return function (fa) { return M.chain(fa, O.match(onNone, M.of)); }; };\n}\nexport function map(F) {\n    return map_(F, O.Functor);\n}\nexport function ap(F) {\n    return ap_(F, O.Apply);\n}\nexport function chain(M) {\n    var flatMapM = flatMap(M);\n    return function (f) { return function (ma) { return flatMapM(ma, f); }; };\n}\n/** @internal */\nexport function flatMap(M) {\n    var zeroM = zero(M);\n    return function (ma, f) {\n        return M.chain(ma, O.match(function () { return zeroM(); }, f));\n    };\n}\nexport function alt(M) {\n    var _some = some(M);\n    return function (second) { return function (first) { return M.chain(first, O.match(second, _some)); }; };\n}\n/** @deprecated */\nexport function getOptionM(M) {\n    var apM = ap(M);\n    var mapM = map(M);\n    var chainM = chain(M);\n    var altM = alt(M);\n    var foldM = matchE(M);\n    var getOrElseM = getOrElse(M);\n    var zeroM = zero(M);\n    return {\n        map: function (fa, f) { return pipe(fa, mapM(f)); },\n        ap: function (fab, fa) { return pipe(fab, apM(fa)); },\n        of: some(M),\n        chain: function (ma, f) { return pipe(ma, chainM(f)); },\n        alt: function (fa, that) { return pipe(fa, altM(that)); },\n        fold: function (fa, onNone, onSome) { return pipe(fa, foldM(onNone, onSome)); },\n        getOrElse: function (fa, onNone) { return pipe(fa, getOrElseM(onNone)); },\n        fromM: fromF(M),\n        none: function () { return zeroM(); }\n    };\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';\nimport * as chainable from './Chain';\nimport { compact as compact_, separate as separate_ } from './Compactable';\nimport { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';\nimport { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, tapEither as tapEither_ } from './FromEither';\nimport { fromIOK as fromIOK_, tapIO as tapIO_ } from './FromIO';\nimport { fromTaskK as fromTaskK_, tapTask as tapTask_ } from './FromTask';\nimport { dual, flow, identity, pipe, SK } from './function';\nimport { as as as_, asUnit as asUnit_, bindTo as bindTo_, flap as flap_, let as let__ } from './Functor';\nimport * as _ from './internal';\nimport * as O from './Option';\nimport * as OT from './OptionT';\nimport * as T from './Task';\nimport { guard as guard_ } from './Zero';\n// -------------------------------------------------------------------------------------\n// constructors\n// -------------------------------------------------------------------------------------\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var some = /*#__PURE__*/ OT.some(T.Pointed);\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromPredicate = /*#__PURE__*/ OT.fromPredicate(T.Pointed);\n// -------------------------------------------------------------------------------------\n// conversions\n// -------------------------------------------------------------------------------------\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromOption = T.of;\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromEither = /*#__PURE__*/ OT.fromEither(T.Pointed);\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromIO = function (ma) { return fromTask(T.fromIO(ma)); };\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromTask = /*#__PURE__*/ OT.fromF(T.Functor);\n/**\n * @category conversions\n * @since 2.11.0\n */\nexport var fromTaskEither = /*#__PURE__*/ T.map(O.fromEither);\n/**\n * @category pattern matching\n * @since 2.10.0\n */\nexport var match = \n/*#__PURE__*/ OT.match(T.Functor);\n/**\n * Less strict version of [`match`](#match).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchW = match;\n/**\n * The `E` suffix (short for **E**ffect) means that the handlers return an effect (`Task`).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchE = \n/*#__PURE__*/ OT.matchE(T.Chain);\n/**\n * Alias of [`matchE`](#matche).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var fold = matchE;\n/**\n * Less strict version of [`matchE`](#matche).\n *\n * The `W` suffix (short for **W**idening) means that the handler return types will be merged.\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var matchEW = matchE;\n/**\n * Alias of [`matchEW`](#matchew).\n *\n * @category pattern matching\n * @since 2.10.0\n */\nexport var foldW = matchEW;\n/**\n * @category error handling\n * @since 2.10.0\n */\nexport var getOrElse = /*#__PURE__*/ OT.getOrElse(T.Monad);\n/**\n * Less strict version of [`getOrElse`](#getorelse).\n *\n * The `W` suffix (short for **W**idening) means that the handler return type will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var getOrElseW = getOrElse;\n/**\n * @category conversions\n * @since 2.10.0\n */\nexport var fromNullable = /*#__PURE__*/ OT.fromNullable(T.Pointed);\n/**\n * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Option` instead.\n *\n * See also [`tryCatchK`](#trycatchk).\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatch = function (f) {\n    return function () { return __awaiter(void 0, void 0, void 0, function () {\n        var reason_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    return [4 /*yield*/, f().then(_.some)];\n                case 1: return [2 /*return*/, _a.sent()];\n                case 2:\n                    reason_1 = _a.sent();\n                    return [2 /*return*/, _.none];\n                case 3: return [2 /*return*/];\n            }\n        });\n    }); };\n};\n/**\n * Converts a function returning a `Promise` to one returning a `TaskOption`.\n *\n * @category interop\n * @since 2.10.0\n */\nexport var tryCatchK = function (f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return tryCatch(function () { return f.apply(void 0, a); });\n    };\n};\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromNullableK = /*#__PURE__*/ OT.fromNullableK(T.Pointed);\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainNullableK = /*#__PURE__*/ OT.chainNullableK(T.Monad);\n// -------------------------------------------------------------------------------------\n// combinators\n// -------------------------------------------------------------------------------------\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromOptionK = /*#__PURE__*/ OT.fromOptionK(T.Pointed);\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var chainOptionK = \n/*#__PURE__*/ OT.chainOptionK(T.Monad);\n/**\n * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types\n * use the type constructor `F` to represent some computational context.\n *\n * @category mapping\n * @since 2.10.0\n */\nexport var map = /*#__PURE__*/ OT.map(T.Functor);\n/**\n * @since 2.10.0\n */\nexport var ap = /*#__PURE__*/ OT.ap(T.ApplyPar);\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var of = some;\n/** @internal */\nvar _FromIO = {\n    fromIO: fromIO\n};\n/** @internal */\nvar _FromTask = {\n    fromTask: fromTask\n};\n/**\n * @category sequencing\n * @since 2.14.0\n */\nexport var flatMap = /*#__PURE__*/ dual(2, OT.flatMap(T.Monad));\n/** @internal */\nvar _FlatMap = {\n    flatMap: flatMap\n};\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapIO = /*#__PURE__*/ _.flatMapIO(_FromIO, _FlatMap);\n/**\n * @category sequencing\n * @since 2.16.0\n */\nexport var flatMapTask = /*#__PURE__*/ _.flatMapTask(_FromTask, _FlatMap);\n/**\n * @category sequencing\n * @since 2.10.0\n */\nexport var flatten = /*#__PURE__*/ flatMap(identity);\n/**\n * @category error handling\n * @since 2.10.0\n */\nexport var alt = /*#__PURE__*/ OT.alt(T.Monad);\n/**\n * Less strict version of [`alt`](#alt).\n *\n * The `W` suffix (short for **W**idening) means that the return types will be merged.\n *\n * @category error handling\n * @since 2.10.0\n */\nexport var altW = alt;\n/**\n * @since 2.10.0\n */\nexport var zero = /*#__PURE__*/ OT.zero(T.Pointed);\n/**\n * @category constructors\n * @since 2.10.0\n */\nexport var none = /*#__PURE__*/ zero();\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var compact = /*#__PURE__*/ compact_(T.Functor, O.Compactable);\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var separate = /*#__PURE__*/ separate_(T.Functor, O.Compactable, O.Functor);\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var filter = /*#__PURE__*/ filter_(T.Functor, O.Filterable);\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var filterMap = \n/*#__PURE__*/ filterMap_(T.Functor, O.Filterable);\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var partition = /*#__PURE__*/ partition_(T.Functor, O.Filterable);\n/**\n * @category filtering\n * @since 2.10.0\n */\nexport var partitionMap = /*#__PURE__*/ partitionMap_(T.Functor, O.Filterable);\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\nvar _map = function (fa, f) { return pipe(fa, map(f)); };\nvar _ap = function (fab, fa) { return pipe(fab, ap(fa)); };\n/* istanbul ignore next */\nvar _alt = function (fa, that) { return pipe(fa, alt(that)); };\n/* istanbul ignore next */\nvar _filter = function (fa, predicate) {\n    return pipe(fa, filter(predicate));\n};\n/* istanbul ignore next */\nvar _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };\n/* istanbul ignore next */\nvar _partition = function (fa, predicate) {\n    return pipe(fa, partition(predicate));\n};\n/* istanbul ignore next */\nvar _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };\n/**\n * @category type lambdas\n * @since 2.10.0\n */\nexport var URI = 'TaskOption';\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Functor = {\n    URI: URI,\n    map: _map\n};\n/**\n * Maps the `Some` value of this `TaskOption` to the specified constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var as = dual(2, as_(Functor));\n/**\n * Maps the `Some` value of this `TaskOption` to the void constant value.\n *\n * @category mapping\n * @since 2.16.0\n */\nexport var asUnit = asUnit_(Functor);\n/**\n * @category mapping\n * @since 2.10.0\n */\nexport var flap = /*#__PURE__*/ flap_(Functor);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Pointed = {\n    URI: URI,\n    of: of\n};\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplyPar = {\n    URI: URI,\n    map: _map,\n    ap: _ap\n};\n/**\n * Combine two effectful actions, keeping only the result of the first.\n *\n * @since 2.10.0\n */\nexport var apFirst = /*#__PURE__*/ apFirst_(ApplyPar);\n/**\n * Combine two effectful actions, keeping only the result of the second.\n *\n * @since 2.10.0\n */\nexport var apSecond = /*#__PURE__*/ apSecond_(ApplyPar);\n/**\n * Runs computations in parallel.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplicativePar = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of\n};\nvar _apSeq = function (fab, fa) { return flatMap(fab, function (f) { return pipe(fa, map(f)); }); };\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplySeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq\n};\n/**\n * Runs computations sequentially.\n *\n * @category instances\n * @since 2.10.0\n */\nexport var ApplicativeSeq = {\n    URI: URI,\n    map: _map,\n    ap: _apSeq,\n    of: of\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Chain = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var FromEither = {\n    URI: URI,\n    fromEither: fromEither\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromIO = {\n    URI: URI,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var FromTask = {\n    URI: URI,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @category combinators\n * @since 2.15.0\n */\nexport var tap = /*#__PURE__*/ dual(2, chainable.tap(Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as TO from 'fp-ts/TaskOption'\n * import * as O from 'fp-ts/Option'\n * import * as E from 'fp-ts/Either'\n *\n * const compute = (value: number) => pipe(\n *   TO.of(value),\n *   TO.tapEither((value) => value > 0 ? E.right('ok') : E.left('error')),\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await compute(1)(), O.of(1))\n *   assert.deepStrictEqual(await compute(-1)(), O.none)\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapEither = /*#__PURE__*/ dual(2, tapEither_(FromEither, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import { pipe } from 'fp-ts/function'\n * import * as TO from 'fp-ts/TaskOption'\n * import * as O from 'fp-ts/Option'\n * import * as Console from 'fp-ts/Console'\n *\n *\n * // Will produce `Hello, fp-ts` to the stdout\n * const effectA = TO.tapIO(\n *   TO.of(1),\n *   (value) => Console.log(`Hello, ${value}`)\n * )\n *\n * // No output to the stdout\n * const effectB = pipe(\n *   TO.none as TO.TaskOption<string>,\n *   TO.tapIO((value) => Console.log(`Hello, ${value}`))\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effectA(), O.of(1))\n *   assert.deepStrictEqual(await effectB(), O.none)\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapIO = /*#__PURE__*/ dual(2, tapIO_(FromIO, Chain));\n/**\n * Composes computations in sequence, using the return value of one computation to determine the next computation and\n * keeping only the result of the first.\n *\n * @example\n * import * as TO from 'fp-ts/TaskOption'\n * import * as O from 'fp-ts/Option'\n * import * as T from 'fp-ts/Task'\n *\n * const effect = TO.tapIO(\n *   TO.of(1),\n *   (value) => T.of(value + 1)\n * )\n *\n * async function test() {\n *   assert.deepStrictEqual(await effect(), O.of(1))\n * }\n *\n * test()\n *\n * @category combinators\n * @since 2.16.0\n */\nexport var tapTask = /*#__PURE__*/ dual(2, tapTask_(FromTask, Chain));\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Alt = {\n    URI: URI,\n    map: _map,\n    alt: _alt\n};\n/**\n * @category instances\n * @since 2.11.0\n */\nexport var Zero = {\n    URI: URI,\n    zero: zero\n};\n/**\n * @category do notation\n * @since 2.11.0\n */\nexport var guard = /*#__PURE__*/ guard_(Zero, Pointed);\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Alternative = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    alt: _alt,\n    zero: zero\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Monad = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadIO = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    fromIO: fromIO\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var MonadTask = {\n    URI: URI,\n    map: _map,\n    ap: _ap,\n    of: of,\n    chain: flatMap,\n    fromIO: fromIO,\n    fromTask: fromTask\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Compactable = {\n    URI: URI,\n    compact: compact,\n    separate: separate\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport var Filterable = {\n    URI: URI,\n    map: _map,\n    compact: compact,\n    separate: separate,\n    filter: _filter,\n    filterMap: _filterMap,\n    partition: _partition,\n    partitionMap: _partitionMap\n};\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromIOK = \n/*#__PURE__*/ fromIOK_(FromIO);\n/**\n * Alias of `flatMapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainIOK = flatMapIO;\n/**\n * Alias of `tapIO`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstIOK = tapIO;\n/**\n * @category lifting\n * @since 2.12.0\n */\nexport var fromEitherK = /*#__PURE__*/ fromEitherK_(FromEither);\n/**\n * @category sequencing\n * @since 2.12.0\n */\nexport var chainEitherK = \n/*#__PURE__*/ chainEitherK_(FromEither, Chain);\n/**\n * Alias of `tapEither`.\n *\n * @category legacy\n * @since 2.12.0\n */\nexport var chainFirstEitherK = tapEither;\n/**\n * @category lifting\n * @since 2.10.0\n */\nexport var fromTaskK = \n/*#__PURE__*/ fromTaskK_(FromTask);\n/**\n * Alias of `flatMapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainTaskK = flatMapTask;\n/**\n * Alias of `tapTask`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirstTaskK = tapTask;\n// -------------------------------------------------------------------------------------\n// do notation\n// -------------------------------------------------------------------------------------\n/**\n * @category do notation\n * @since 2.10.0\n */\nexport var Do = /*#__PURE__*/ of(_.emptyRecord);\n/**\n * @category do notation\n * @since 2.10.0\n */\nexport var bindTo = /*#__PURE__*/ bindTo_(Functor);\nvar let_ = /*#__PURE__*/ let__(Functor);\nexport { \n/**\n * @category do notation\n * @since 2.13.0\n */\nlet_ as let };\n/**\n * @category do notation\n * @since 2.10.0\n */\nexport var bind = /*#__PURE__*/ chainable.bind(Chain);\n/**\n * @category do notation\n * @since 2.10.0\n */\nexport var apS = /*#__PURE__*/ apS_(ApplyPar);\n/**\n * @since 2.11.0\n */\nexport var ApT = /*#__PURE__*/ of(_.emptyReadonlyArray);\n// -------------------------------------------------------------------------------------\n// array utils\n// -------------------------------------------------------------------------------------\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndex = function (f) {\n    return flow(T.traverseReadonlyNonEmptyArrayWithIndex(f), T.map(O.traverseReadonlyNonEmptyArrayWithIndex(SK)));\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativePar)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndex = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndex(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyNonEmptyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyNonEmptyArrayWithIndexSeq = function (f) {\n    return function (as) {\n        return function () {\n            return _.tail(as).reduce(function (acc, a, i) {\n                return acc.then(function (obs) {\n                    return _.isNone(obs)\n                        ? acc\n                        : f(i + 1, a)().then(function (ob) {\n                            if (_.isNone(ob)) {\n                                return ob;\n                            }\n                            obs.value.push(ob.value);\n                            return obs;\n                        });\n                });\n            }, f(0, _.head(as))().then(O.map(_.singleton)));\n        };\n    };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.11.0\n */\nexport var traverseReadonlyArrayWithIndexSeq = function (f) {\n    var g = traverseReadonlyNonEmptyArrayWithIndexSeq(f);\n    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };\n};\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(Applicative)`.\n *\n * @category traversing\n * @since 2.10.0\n */\nexport var traverseArrayWithIndex = traverseReadonlyArrayWithIndex;\n/**\n * Equivalent to `ReadonlyArray#traverse(Applicative)`.\n *\n * @category traversing\n * @since 2.10.0\n */\nexport var traverseArray = function (f) { return traverseReadonlyArrayWithIndex(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(Applicative)`.\n *\n * @category traversing\n * @since 2.10.0\n */\nexport var sequenceArray = \n/*#__PURE__*/ traverseArray(identity);\n/**\n * Equivalent to `ReadonlyArray#traverseWithIndex(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.10.0\n */\nexport var traverseSeqArrayWithIndex = traverseReadonlyArrayWithIndexSeq;\n/**\n * Equivalent to `ReadonlyArray#traverse(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.10.0\n */\nexport var traverseSeqArray = function (f) { return traverseReadonlyArrayWithIndexSeq(function (_, a) { return f(a); }); };\n/**\n * Equivalent to `ReadonlyArray#sequence(ApplicativeSeq)`.\n *\n * @category traversing\n * @since 2.10.0\n */\nexport var sequenceSeqArray = \n/*#__PURE__*/ traverseSeqArray(identity);\n// -------------------------------------------------------------------------------------\n// legacy\n// -------------------------------------------------------------------------------------\n/**\n * Alias of `flatMap`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chain = flatMap;\n/**\n * Alias of `tap`.\n *\n * @category legacy\n * @since 2.10.0\n */\nexport var chainFirst = tap;\n"],"names":["some","F","flow","O.some","zero","constant","O.none","fromNullable","O.fromNullable","fromPredicate","predicate","a","O.fromPredicate","match","onNone","onSome","ma","O.match","map","map_","O.Functor","flatMap","M","zeroM","f","__awaiter","this","thisArg","_arguments","P","generator","adopt","value","resolve","reject","fulfilled","step","e","rejected","result","__generator","body","_","t","y","g","verb","n","v","op","OT.some","T.Pointed","OT.fromPredicate","OT.match","T.Functor","matchW","OT.fromNullable","tryCatch","_a","_.some","_.none","OT.map","of","dual","OT.flatMap","T.Monad","_map","fa","pipe","URI","_apSeq","fab","ApplicativeSeq","chain"],"mappings":"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","x_google_ignoreList":[0,1]}