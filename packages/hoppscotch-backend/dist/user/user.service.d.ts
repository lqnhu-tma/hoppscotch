import { PrismaService } from 'src/prisma/prisma.service';
import * as O from 'fp-ts/Option';
import * as E from 'fp-ts/Either';
import * as TO from 'fp-ts/TaskOption';
import * as TE from 'fp-ts/TaskEither';
import { AuthUser } from 'src/types/AuthUser';
import { User } from './user.model';
import { PubSubService } from 'src/pubsub/pubsub.service';
import { UserDataHandler } from './user.data.handler';
import { User as DbUser } from '@prisma/client';
import { OffsetPaginationArgs } from 'src/types/input-types.args';
export declare class UserService {
    private prisma;
    private readonly pubsub;
    constructor(prisma: PrismaService, pubsub: PubSubService);
    private userDataHandlers;
    registerUserDataHandler(handler: UserDataHandler): void;
    convertDbUserToUser(dbUser: DbUser): User;
    findUserByEmail(email: string): Promise<O.None | O.Some<AuthUser>>;
    findUserById(userUid: string): Promise<O.None | O.Some<AuthUser>>;
    findUsersByIds(userUIDs: string[]): Promise<AuthUser[]>;
    updateUserRefreshToken(refreshTokenHash: string, userUid: string): Promise<E.Right<any> | E.Left<"user/not_found">>;
    createUserViaMagicLink(email: string): Promise<any>;
    createUserSSO(accessTokenSSO: string, refreshTokenSSO: string, profile: any): Promise<any>;
    createProviderAccount(user: AuthUser, accessToken: string, refreshToken: string, profile: any): Promise<any>;
    updateUserDetails(user: AuthUser, profile: any): Promise<E.Right<any> | E.Left<"user/not_found">>;
    updateUserSessions(user: AuthUser, currentSession: string, sessionType: string): Promise<E.Right<User> | E.Left<string>>;
    updateUserDisplayName(userUID: string, displayName: string): Promise<E.Left<"user/not_found"> | E.Right<User> | E.Left<"user/short_display_name">>;
    updateUserLastLoggedOn(userUid: string): Promise<E.Left<"user/not_found"> | E.Right<boolean>>;
    updateUserLastActiveOn(userUid: string): Promise<E.Left<"user/not_found"> | E.Right<boolean>>;
    validateSession(sessionData: string): Promise<E.Right<any> | E.Left<string>>;
    fetchAllUsers(cursorID: string, take: number): Promise<any>;
    fetchAllUsersV2(searchString: string, paginationOption: OffsetPaginationArgs): Promise<any>;
    getUsersCount(): Promise<any>;
    makeAdmin(userUID: string): Promise<E.Right<any> | E.Left<"user/not_found">>;
    makeAdmins(userUIDs: string[]): Promise<E.Left<"user/update_failed"> | E.Right<boolean>>;
    fetchAdminUsers(): Promise<any>;
    deleteUserAccount(uid: string): Promise<E.Left<"user/not_found"> | E.Right<boolean>>;
    getUserDeletionErrors(user: AuthUser): TO.TaskOption<string[]>;
    deleteUserByUID(user: AuthUser): TE.TaskEither<string, boolean>;
    removeUserAsAdmin(userUID: string): Promise<E.Right<any> | E.Left<"user/not_found">>;
    removeUsersAsAdmin(userUIDs: string[]): Promise<E.Right<boolean> | E.Left<"user/users_not_found">>;
}
